/**
 * @file mouse.h
 * @author Group 9 Section 2
 *         Kumara Ritvik Oruganti (okritvik@umd.edu)
 *         Adarsh Malapaka (amalapak@umd.edu)
 *         Venkata Sairam Polina (sairamp@umd.edu)
 *         Initial class template by: Prof. Zeid Kootbally (zeidk@umd.edu) 
 * @brief The file contains the Mouse class to implement the movements, wall checking and path generation of the micromouse. 
 * @version 0.3
 * @date 2021-11-13
 *
 * @copyright Copyright (c) 2021
 *
 */

 /*! \mainpage Maze search algorithm
  *
  * This project consists of searching a path in a maze
  * and then task a mouse (robot) to follow the path.
  * - \subpage searchingPathPage "Searching a path"
  *
  * - \subpage followingPathPage "Following a path"
  *
  */

  /*! \page searchingPathPage Searching a path
   *
   * The search algorithm used for searching a path in a maze relies on
   * the depth-first search (DFS) approach. This algorithm is implemented in rwa2::Mouse::search_maze()
   *
   */

   /*! \page followingPathPage Following a path
    *
    * To follow a path generated by DFS, methods from the class API (api/api.h) must be used to interact
    * with the micromouse simulator.
    * - Methods of the API class are documented <a href="https://github.com/mackorone/mms#summary">here</a>.
    */


#ifndef MICROMOUSE_H
#define MICROMOUSE_H

#include "../node/node.h"
#include "../util/util.h"
#include "../api/api.h"  
#include <array>
#include <vector>
#include <stack>
#include <algorithm>
#include <iostream>
#include <stdlib.h>
#include <time.h>

namespace rwa2 {
    /**
     * @brief This class is used to compute a path and execute the path.
     *
     */
    class Mouse {
        public:

            /**
             * @brief Construct a new MicroMouse object
             *
             * The robot is always at (0,0) and facing NORTH when the simulator starts
             * Initializing the current node, top node and next node of the maze
             * Initializing a random number between {7,8} to the goal node coordinates
             * 
             */
            Mouse() :m_x{ 0 }, m_y{ 0 }, m_direction{ direction::NORTH } {
                //initialize the maze by placing around the perimeter of the maze
                for (int x = 0; x < m_maze_width; x += 1) {
                    for (int y = 0; y < m_maze_height; y += 1) {
                        m_visited_nodes.at(x).at(y)=false;
                        m_maze.at(x).at(y).set_wall(direction::NORTH, (y == m_maze_height - 1));
                        m_maze.at(x).at(y).set_wall(direction::EAST, (x == m_maze_width - 1));
                        m_maze.at(x).at(y).set_wall(direction::SOUTH, (y == 0));
                        m_maze.at(x).at(y).set_wall(direction::WEST, (x == 0));
                    }
                }
                m_curr_node.at(0) = m_x;
                m_curr_node.at(1) = m_y;
                m_top_node.at(0) = m_x;
                m_top_node.at(1) = m_y;
                m_next_node.at(0) = m_x;
                m_next_node.at(1) = m_y;
                srand(time(0)); // using present time as seed generator for random goal coordinates
                m_goal_node.at(0) = (rand()%2)+7; // random number between 7 & 8
                m_goal_node.at(1) = (rand()%2)+7; // random number between 7 & 8
                std::cerr << "Goal Nodes: " << m_goal_node.at(0) << " " << m_goal_node.at(1) << "\n";
            }

            /**
             * @brief this method visually sets the walls in the simulator
             * 
             */
            void display_walls();
            
            //IMPLEMENT THE METHODS BELOW

            //Note: Come up with your own parameters and implementations
            /**
             * @brief Implement Depth First Search (DFS) algortihm to compute a path between 2 nodes in a maze. 
             *        This function calls the DFS function recursively to compute the path from present node.
             * 
             * @return true A path is found
             * @return false A path is not found
             */
            bool search_maze();
            
            /**
             * @brief Makes the mouse to move forward by 1 node
             *
             */
            void move_forward();
            
            /**
             * @brief Makes the mouse rotate 90 deg CCW
             *
             */
            void turn_left();
            
            /**
             * @brief Makes the mouse rotate 90 deg CW
             *
             */
            void turn_right();

            /**
             * @brief This function calculates the next node from the present node depending on the direction
             * 
             * @param dir Direction with respect to which next node is calculated
             * @param m_next_node Array of next node coordinates to be updated
             * @param m_curr_node Array of present node coordinates
             * @return true After updating the next node successfully
             */
            bool update_next_node(const int& dir,std::array<int,2>& m_next_node, const std::array<int,2>& m_curr_node);
            
            /**
             * @brief This function checks if the next node is in the visited nodes array or not
             * 
             * @param m_visited_nodes 2D Array of boolean value correspoinding to already visited nodes   
             * @param m_next_node Array of next node coordinates that have to be checked
             * @return true If the node has already been visited
             * @return false If the node has not been visited
             */
            bool is_visited(std::array<std::array<bool,16>,16> &m_visited_nodes, std::array<int,2> &m_next_node);
            
            /**
             * @brief This function computes the path from the mouse's current position to the goal recursively using the Depth First Search algorithm. 
             *        It is called in the search_maze() function and accounts for backtracking.
             * 
             * @param l_x integer Local x index from which the DFS has to be computed to reach the goal
             * @param l_y integer Local y index from which the DFS has to be computed to reach the goal
             * @return true If there is a path found from the (l_x, l_y) node to the goal node
             * @return false If there is no path found from the (l_x, l_y) node to the goal node
             */
            bool depth_first_search(int l_x,int l_y);

            /**
             * @brief This function moves the mouse to the next node if there is no wall in between the current node and the next node.
             * 
             * @param m_top_node Array of the next node coordinates in the stack
             * @param m_curr_node Array of present node coordinates of the mouse
             * @param m_direction integer Direction in which the mouse has to travel
             * @return true If the mouse moves successfully to the next node 
             * @return false If the mouse can't move to the next node.
             */
            
            bool move_to_next_node(const std::array<int,2>& m_top_node,const std::array<int,2>& m_curr_node, int& m_direction);


        private:

            static const int m_maze_width{ 16 }; // width of the maze
            static const int m_maze_height{ 16 };// height of the maze
            int m_x; //x position of the robot in the maze
            int m_y; //y position of the robot in the maze
            int m_direction; //direction of the robot in the maze
            std::array<std::array<Node, m_maze_width>, m_maze_height> m_maze; //2D array maze object
            std::array<std::array<bool,m_maze_width>,m_maze_height> m_visited_nodes; //2D array of boolean visited nodes
            std::stack<std::array<int,2>> m_node_stack; // Stack containing the path computed by the DFS function
            std::stack<std::array<int,2>> m_final_path; // Stack containing the reverse of the m_node_stack (for moving the mouse in the computed path)
            std::array<int,2> m_curr_node;  // current node coordinates of the mouse
            std::array<int,2> m_top_node; // top node coordinates of the stack
            std::array<int,2> m_next_node; // next node coordinates of the stack
            std::array<int,2> m_goal_node; // goal node coordinates which are set randomly using the srand(), rand() & time() functions
    };
}
#endif